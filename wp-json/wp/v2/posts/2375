{"id":2375,"date":"2021-01-05T08:27:38","date_gmt":"2021-01-05T08:27:38","guid":{"rendered":"https:\/\/jacekjeznach.com\/?p=2375"},"modified":"2022-02-03T09:42:53","modified_gmt":"2022-02-03T09:42:53","slug":"sorting-searching-algorithms","status":"publish","type":"post","link":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/","title":{"rendered":"Algorithms and Data Structures (Part 2)"},"content":{"rendered":"<h2>Searching and Sorting<\/h2>\n<p>Computers are very good at performing certain repetitive tasks\u2014if they are programmed correctly. That can be a big \u201cif.\u201d It is important to realize that any mistake that is made in code can be amplified exponentially by the power of a computer. If your algorithm has a tiny flaw that makes it less efficient that flaw will be magnified as the task is repeated millions and billions of times by a computer.<\/p>\n<p>The tasks of searching and sorting are both comparable to everyday tasks completed by humans. Humans search and sort objects, papers and things, whereas computers sort data. It is easy to compare these type of tasks to the human perspective to explain them. For instance, we search for things all the time. \u201cWhere did my keys go?\u201d you may have asked for the hundredth time in your life. We try to find our favorite shirt, our wallet, our cup of coffee: \u201cI swear it was just here a minute ago!\u201d Usually there is a method to our searching for things. Sometimes we want to find something that is kept with other things of the same type. This is why we have things like a silverware drawer. We know that in this drawer, we keep our silverware. And what helps us find the fork? The silverware is sorted by type. So we also sort things and as it turns out, sorting things makes it easier for us to search for things. This is true for computers as well.<\/p>\n<p>We began this unit with a discussion of Google search\u2014the search of all searches in the biggest database ever made, the internet. Usually programmers don\u2019t have such a daunting search space, they have a simple data set, something like a linked list or an array.<\/p>\n<ins class=\"adsbygoogle\"\r\n     style=\"display:block; text-align:center;\"\r\n     data-ad-layout=\"in-article\"\r\n     data-ad-format=\"fluid\"\r\n     data-ad-client=\"ca-pub-7829400583245190\"\r\n     data-ad-slot=\"7226953054\"><\/ins>\r\n<script>\r\n     (adsbygoogle = window.adsbygoogle || []).push({});\r\n<\/script>\n<h3>Gathering and Sorting Data<\/h3>\n<p>When data is input into a computer, the process depends on the type of data collected. It\u2019s similar to real life\u2014sometimes things come to you randomly, but sometimes they are already in order. Or, as things often go, they are in a kind of order, but not perfectly arranged. It may be that once data is input into a computer that it is happily already sorted, but most times this is not the case. We must do some additional processing of the data: a sort.<\/p>\n<p>Let\u2019s say you have a box full of kids toys and you want to sort them in some kind of order. First you have to choose what the sort criteria will be. What will you use to sort these toys? You could sort them alphabetically by name, but what if the stuffed \u201cbear\u201d is also called \u201cPeter\u201d? Do you use \u201cb\u201d or \u201cp\u201d? It can be ambiguous. You could sort by size of the toy\u2014but would you be using length or total volume? Sorting criteria must be exact. Even when sorting alphabetically decisions must be made\u2014is there a different between capital and lowercase? Which is first?<\/p>\n<p>Computers cannot work with ambiguity\u2014everything must be exact. Fortunately, all data in a computer is represented in binary, and we can sort by the value of these binary numbers. The most common sorts, then, would be by numeric value or by alpha-numeric codes using one of the common computer encoding systems such as <a href=\"https:\/\/en.wikipedia.org\/wiki\/Unicode\">Unicode<\/a>. Since each letter and symbol has a binary value attached to it, that value can be used to sort.<\/p>\n<p>Of course, the sort must be either ascending or descending; in other words, smallest to largest or vice versa. Once you have figured out your sorting method, it\u2019s time to sort.<\/p>\n<p>Looking back at our box of toys, imagine what you would do first if we sorted by largest toy. Your eye would quickly scan all the toys for the one taking up the most space. Then you\u2019d take it and put it first (or last) in the order. You are making order out of chaos. Each time when you pick the next toy, you will scan them all\u2014and each time you do this, the number of toys left is smaller so it should take slightly less time. The last toy will take almost no time since it is the only one left and no visual scanning is required. Some steps will be easier since the next toy choice might be obvious, but some steps might take longer because two toys might be very close in size (or identical, which also requires a rule).<\/p>\n<p>As you can see, sorting is a bit of a complex task that takes time and also must have a very specific set of criteria or rules. In fact, we could call our set of rules for searching an algorithm.<\/p>\n<h3>Searching for Data<\/h3>\n<p>Let\u2019s imagine a different kind of scenario. Today, we live in a very digital world, but not long ago everyone in the United States and many other countries had their own phone book. This enormous tome listed the phone numbers of everyone (with permission) in the local area, along with the numbers of businesses.<\/p>\n<p>Today, phonebooks are still to be found littering the landscape, an echo of the age of paper. However, phonebooks serve as a perfect example of sorting and searching. The list of all of the phone numbers was first sorted. Of course, the publishers could have chosen to sort by number, but most people were looking for the number and already knew the name. The sorting algorithm for a phone book was decided as the last name followed by the first name. Once all the names were sorted, the phone numbers and addresses were printed next to them in the book.<\/p>\n<p><a href=\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/4248396588_baf974a894_o.0.0-e1641371246884.jpg\"><img loading=\"lazy\" class=\"alignnone size-full wp-image-2376\" src=\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/4248396588_baf974a894_o.0.0-e1641371246884.jpg\" alt=\"\" width=\"1400\" height=\"504\" srcset=\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/4248396588_baf974a894_o.0.0-e1641371246884.jpg 1400w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/4248396588_baf974a894_o.0.0-e1641371246884-350x126.jpg 350w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/4248396588_baf974a894_o.0.0-e1641371246884-700x252.jpg 700w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/4248396588_baf974a894_o.0.0-e1641371246884-768x276.jpg 768w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/4248396588_baf974a894_o.0.0-e1641371246884-120x43.jpg 120w\" sizes=\"(max-width: 1400px) 100vw, 1400px\" \/><\/a><\/p>\n<p>Once the books were delivered, a person searching for the name could open the book and look. Let\u2019s say the person in our example is Ken, and he is looking up Josh Rodriguez. How would it be best for him to search? You might say that he should open the book near the end, since \u201cR\u201d is farther down through the alphabet. However, there may be many names that start with \u201cS\u201d and so the bulk of the last part of the book would be those names. However, Ken decides to choose his starting point, he will then have to decide whether to go forward or backward in the book. If he opens about three quarters of the way through and sees the letter \u201cS,\u201d he will go backwards. However, if he opens to \u201cO,\u201d he knows he must go forward in the book. He also can search through one page at a time, looking at the letters, or simply skip a number of pages to see what letter he finds next.<\/p>\n<ins class=\"adsbygoogle\"\r\n     style=\"display:block; text-align:center;\"\r\n     data-ad-layout=\"in-article\"\r\n     data-ad-format=\"fluid\"\r\n     data-ad-client=\"ca-pub-7829400583245190\"\r\n     data-ad-slot=\"9851625702\"><\/ins>\r\n<script>\r\n     (adsbygoogle = window.adsbygoogle || []).push({});\r\n<\/script>\r\n\n<p>Obviously, leafing through every page will take more time than jumping to a new page, but once you are close to the answer, leafing might become faster. It really depends on the data. We can pick a search algorithm for Ken and make it very simple. We tell him, \u201cKen, this is what you\u2019re going to do. You open the book halfway. Then, you decide to go forward or backward. Once you decide that, you will split the remaining pages in half and open to that page. You will then decide again and keep splitting the pages in half until you have arrived at Mr. Rodriguez.\u201d This is actually what we call a binary search, since it continually splits the data size into two.<\/p>\n<p>There are many ways we could tell Ken, or a computer, to search a data set.<\/p>\n<h2>Search Algorithms<\/h2>\n<p>Let\u2019s take a look at some common searching rules. Some are more efficient than others. Many of them depend on the data itself, and data could be random, sorted, partially sorted, or in some other unusual order.<\/p>\n<h4>Linear search<\/h4>\n<p>This kind of search is pretty simple. It starts at the beginning and looks at each element in order. This would be like telling Ken to start at page one of the phonebook and read every single entry until he found Josh Rodriguez. If he was lucky, Josh would be near the beginning, but with a last name of \u201cR\u201d it seems unlikely.<\/p>\n<h4>Jump search<\/h4>\n<p>For this one, we need a little more information. Let\u2019s say the book is 2,500 pages long. We calculate the square root of n, the number of pages, which gives us 50, which we will use for the jump size, or m. Ken will first jump to page 50 and see if Josh is higher or lower, then keep jumping until he is past Josh. Then, he will go back to the previous jump and do a linear search (page by page) on the next 50 pages to find him. As you can see, this is definitely an improvement over a straight linear search.<\/p>\n<h4>Binary search<\/h4>\n<p>This is the one we have already described in our first example. Ken would start at page 1,250 of our 2,500-page book, and if Josh was higher in the list then jump half the remaining space, 625 pages, and keep splitting it until he arrived on the proper page.<\/p>\n<ins class=\"adsbygoogle\"\r\n     style=\"display:block; text-align:center;\"\r\n     data-ad-layout=\"in-article\"\r\n     data-ad-format=\"fluid\"\r\n     data-ad-client=\"ca-pub-7829400583245190\"\r\n     data-ad-slot=\"9851625702\"><\/ins>\r\n<script>\r\n     (adsbygoogle = window.adsbygoogle || []).push({});\r\n<\/script>\r\n\n<p>Depending on the data itself, any of these techniques could be faster or slower than the others. The last two are also dependent on the data being sorted first. Since a linear search simply reads every entry until it finds the correct one, it will work on sorted or unsorted data lists.<\/p>\n<h2>Sorting Algorithms<\/h2>\n<p>We have seen that there is an advantage to searching data if it is first sorted. But how is the data sorted? There are also several different methods we can instruct a computer to use to organize our data.<\/p>\n<p>If we go back to our toy box example, we can imagine a computer doing something similar. However, our brains work a bit differently. We can look at a collection of objects and pick out the largest one without pointing our eye at each one separately\u2014it\u2019s one of the amazing things our brain does for us. However, a computer has to look at each element individually\u2014it can\u2019t look at an entire array or linked list from \u201cabove\u201d like we do to pick. For a computer it is more like looking through a phone book where the pages are hidden: it can\u2019t see them until it opens each one.<\/p>\n<h4>Bubble sort<\/h4>\n<p>One of the simplest types of sorting algorithms is the bubble sort. You can imagine how it works by thinking of the largest values \u201cbubbling\u201d to the top, like air bubbles in your drink. The rules for bubble search are this: starting at the beginning, compare the first two values. If the first one is larger, move it to the second. If it is not, they are already in order. Then compare the next two values and do the same until you reach the end. Once this is done, do it again for every element except the last one, since it will be in order now. Each pass you complete will guarantee one more element is in order. Others may happen to be in order, but the bubble sort will check them all regardless. <a href=\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/67413322-96dfed00-f5c9-11e9-89a4-fbcf724272aa.png\"><img loading=\"lazy\" class=\"alignnone size-full wp-image-2381\" src=\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/67413322-96dfed00-f5c9-11e9-89a4-fbcf724272aa.png\" alt=\"\" width=\"901\" height=\"535\" srcset=\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/67413322-96dfed00-f5c9-11e9-89a4-fbcf724272aa.png 901w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/67413322-96dfed00-f5c9-11e9-89a4-fbcf724272aa-350x208.png 350w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/67413322-96dfed00-f5c9-11e9-89a4-fbcf724272aa-700x416.png 700w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/67413322-96dfed00-f5c9-11e9-89a4-fbcf724272aa-768x456.png 768w, https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/67413322-96dfed00-f5c9-11e9-89a4-fbcf724272aa-120x71.png 120w\" sizes=\"(max-width: 901px) 100vw, 901px\" \/><\/a><\/p>\n<p>Let\u2019s use a simple array for<strong> our example.<\/strong><\/p>\n<p>(Kayli, Katie, John, Nathan, Anna)<\/p>\n<p>As you can see it has five elements. The first step is to compare Kayli and Katie. Since \u201cy\u201d is after \u201ct\u201d they are out of order, so bubble search will switch them.<\/p>\n<p>(Katie, Kayli, John, Nathan, Anna)<\/p>\n<p>Then Kayli and John are compared. Kayli comes after John, so they are switched.<\/p>\n<p>(Katie, John, Kayli, Nathan, Anna)<\/p>\n<p>Kayli and Nathan are compared and found to be in the correct order, so the list is unchanged for this step.<\/p>\n<p>(Katie, John, Kayli, Nathan, Anna)<\/p>\n<p>Finally, Nathan and Anna are compared, and Nathan is switched with Anna.<\/p>\n<p>(Katie, John, Kayli, Anna, Nathan)<\/p>\n<p>With this method we now know that the last element, \u201cNathan\u201d is in its proper place. Now we must compare the remaining four elements. After that, then the remaining three, then the last two. A regular bubble sort will always take the same number of steps based on the list size. However, a modified bubble sort could be instructed to stop if the list is sorted just by detecting if there were no swaps made. If no swaps are needed, the list is already in order. You can see that the number of comparisons in each pass is n-1, where n is the array size. In this case there were four comparisons on five elements.<\/p>\n<ins class=\"adsbygoogle\"\r\n     style=\"display:block; text-align:center;\"\r\n     data-ad-layout=\"in-article\"\r\n     data-ad-format=\"fluid\"\r\n     data-ad-client=\"ca-pub-7829400583245190\"\r\n     data-ad-slot=\"9999429353\"><\/ins>\r\n<script>\r\n     (adsbygoogle = window.adsbygoogle || []).push({});\r\n<\/script>\n<h4>Binary insertion sort<\/h4>\n<p>The binary insertion sort is based on the same method we used for a binary search\u2014by splitting the data in half repeatedly. To sort the data, it builds a new output list and takes items from the input list. The input list are items yet to be sorted, and the output are the ones already sorted. Imagine you\u2019re sorting your toys in the toy box.<\/p>\n<p>First you dump them all on the floor\u2014that\u2019s your input list. Then you place them back in the box one at a time in order, that\u2019s the output list. This example will make more sense with a larger list. Let\u2019s use numerical data this time and assume that the first five elements have already been sorted. So far, we have:<\/p>\n<p><strong>Input (66, 3, 23, 76, 27, 1, 11): yet to be sorted<\/strong><\/p>\n<p><strong>Output (13, 35, 37, 44, 56): sorted<\/strong><\/p>\n<p>The original list, then, had 12 elements. We now reach down for the next toy or element in the list, 66. Remember a computer can\u2019t see a top down view like we do of all the items, it needs to check them individually. However, we can speed this up by splitting the ordered list in half, just like Ken did with the phonebook. The computer looks at the middle element out of the five, which is the third element, 37. 66 is higher, so now it jumps to the top half of the data. It then splits the difference again and looks at the fourth element, which is 44. 66 is larger, so it splits the two remaining into a space of one\u2014now we are at the last comparison. 66 is larger than 56 so it is added to the end of the list. We now have:<\/p>\n<p><strong>Input (3, 23, 76, 27, 1, 11)<\/strong><\/p>\n<p><strong>Output (13, 35, 37, 44, 56, 66)<\/strong><\/p>\n<p>This took three comparisons for a five-element list. A bubble sort would take four comparisons for each pass, so generally speaking, this algorithm is an improvement.<\/p>\n<p>The next step would continue with the input of 3. Since there are an even number of elements (six) we have to split the middle with either the third or fourth. Let\u2019s say the algorithm chooses the third. We compare 3 to 37. It is lower, so we split the remaining space and compare it to 35. 3 is lower again and we compare it to 13. It is lowest again, so 3 is placed at the beginning of the list. The advantage of the binary insertion sort is that it can at the very least eliminate comparing to half of the data elements in the list in the first step. Now we have:<\/p>\n<p><strong>Input (23, 76, 27, 1, 11)<\/strong><\/p>\n<p><strong>Output (3, 13, 35, 37, 44, 56, 66)<\/strong><\/p>\n<p>This process would continue as each element is added to the output list in order, so when the last element is added, the list will be sorted.<\/p>\n<h4>Quicksort<\/h4>\n<p>Search algorithms get different results based on the data set, but Quicksort is regarded as one of the most efficient algorithms overall. Quicksort is more complex than the previous algorithms, but the explanation of how it works is simple. Imagine a teacher with a stack of graded papers. The teacher wants to sort all of the papers by grade. The pile is split into all the grades higher than 55 (this number is the pivot and can be chosen by different methods) and those less than 55. Then the two piles are split around another pivot bringing the total number of piles to four. The teacher then sorts each pile separately and when they are done, can simply put all the piles back together in order from lowest pile to highest. It can be thought of as a \u201cdivide and conquer\u201d type of method. In this example, the stack was split into four piles but, in reality, the data determines how many stacks it is split into for sorting.<\/p>\n<ins class=\"adsbygoogle\"\r\n     style=\"display:block; text-align:center;\"\r\n     data-ad-layout=\"in-article\"\r\n     data-ad-format=\"fluid\"\r\n     data-ad-client=\"ca-pub-7829400583245190\"\r\n     data-ad-slot=\"7226953054\"><\/ins>\r\n<script>\r\n     (adsbygoogle = window.adsbygoogle || []).push({});\r\n<\/script>\n","protected":false},"excerpt":{"rendered":"<p>Searching and Sorting Computers are very good at performing certain repetitive tasks\u2014if they are programmed correctly. That can be a big \u201cif.\u201d It is important to realize that any mistake that is made in code can be amplified exponentially by the power of a computer. If your algorithm has a tiny flaw that makes it [&hellip;]<\/p>\n","protected":false},"author":4,"featured_media":2267,"comment_status":"closed","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[66],"tags":[],"yoast_head":"<!-- This site is optimized with the Yoast SEO plugin v18.0 - https:\/\/yoast.com\/wordpress\/plugins\/seo\/ -->\n<title>Algorithms and Data Structures (Part 2) | Computer Science | JJ<\/title>\n<meta name=\"description\" content=\"how the term algorithm is used in applications of computer science.how to create flowcharts.the details of data structures, such as arrays and stacks.how sorting algorithms work, including quick and bubble sort.how the quality of different algorithms is evaluated.\" \/>\n<meta name=\"robots\" content=\"index, follow, max-snippet:-1, max-image-preview:large, max-video-preview:-1\" \/>\n<link rel=\"canonical\" href=\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/\" \/>\n<meta property=\"og:locale\" content=\"en_US\" \/>\n<meta property=\"og:type\" content=\"article\" \/>\n<meta property=\"og:title\" content=\"Algorithms and Data Structures (Part 2) | Computer Science | JJ\" \/>\n<meta property=\"og:description\" content=\"how the term algorithm is used in applications of computer science.how to create flowcharts.the details of data structures, such as arrays and stacks.how sorting algorithms work, including quick and bubble sort.how the quality of different algorithms is evaluated.\" \/>\n<meta property=\"og:url\" content=\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/\" \/>\n<meta property=\"og:site_name\" content=\"JJ\" \/>\n<meta property=\"article:published_time\" content=\"2021-01-05T08:27:38+00:00\" \/>\n<meta property=\"article:modified_time\" content=\"2022-02-03T09:42:53+00:00\" \/>\n<meta property=\"og:image\" content=\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg\" \/>\n\t<meta property=\"og:image:width\" content=\"2048\" \/>\n\t<meta property=\"og:image:height\" content=\"1367\" \/>\n\t<meta property=\"og:image:type\" content=\"image\/jpeg\" \/>\n<meta name=\"twitter:card\" content=\"summary\" \/>\n<meta name=\"twitter:creator\" content=\"@JeznachJacek\" \/>\n<meta name=\"twitter:site\" content=\"@JeznachJacek\" \/>\n<meta name=\"twitter:label1\" content=\"Written by\" \/>\n\t<meta name=\"twitter:data1\" content=\"Jacek Jeznach\" \/>\n\t<meta name=\"twitter:label2\" content=\"Est. reading time\" \/>\n\t<meta name=\"twitter:data2\" content=\"13 minutes\" \/>\n<script type=\"application\/ld+json\" class=\"yoast-schema-graph\">{\"@context\":\"https:\/\/schema.org\",\"@graph\":[{\"@type\":\"WebSite\",\"@id\":\"https:\/\/jacekjeznach.com\/#website\",\"url\":\"https:\/\/jacekjeznach.com\/\",\"name\":\"JJ\",\"description\":\"Hire Professional  WordPress Expert - providing multiple services including website maintenance and interactive solutions\",\"publisher\":{\"@id\":\"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e\"},\"potentialAction\":[{\"@type\":\"SearchAction\",\"target\":{\"@type\":\"EntryPoint\",\"urlTemplate\":\"https:\/\/jacekjeznach.com\/?s={search_term_string}\"},\"query-input\":\"required name=search_term_string\"}],\"inLanguage\":\"en-US\"},{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#primaryimage\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg\",\"contentUrl\":\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg\",\"width\":2048,\"height\":1367},{\"@type\":\"WebPage\",\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#webpage\",\"url\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/\",\"name\":\"Algorithms and Data Structures (Part 2) | Computer Science | JJ\",\"isPartOf\":{\"@id\":\"https:\/\/jacekjeznach.com\/#website\"},\"primaryImageOfPage\":{\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#primaryimage\"},\"datePublished\":\"2021-01-05T08:27:38+00:00\",\"dateModified\":\"2022-02-03T09:42:53+00:00\",\"description\":\"how the term algorithm is used in applications of computer science.how to create flowcharts.the details of data structures, such as arrays and stacks.how sorting algorithms work, including quick and bubble sort.how the quality of different algorithms is evaluated.\",\"breadcrumb\":{\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#breadcrumb\"},\"inLanguage\":\"en-US\",\"potentialAction\":[{\"@type\":\"ReadAction\",\"target\":[\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/\"]}]},{\"@type\":\"BreadcrumbList\",\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#breadcrumb\",\"itemListElement\":[{\"@type\":\"ListItem\",\"position\":1,\"name\":\"Home\",\"item\":\"https:\/\/jacekjeznach.com\/\"},{\"@type\":\"ListItem\",\"position\":2,\"name\":\"Algorithms and Data Structures (Part 2)\"}]},{\"@type\":\"Article\",\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#article\",\"isPartOf\":{\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#webpage\"},\"author\":{\"@id\":\"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e\"},\"headline\":\"Algorithms and Data Structures (Part 2)\",\"datePublished\":\"2021-01-05T08:27:38+00:00\",\"dateModified\":\"2022-02-03T09:42:53+00:00\",\"mainEntityOfPage\":{\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#webpage\"},\"wordCount\":2716,\"publisher\":{\"@id\":\"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e\"},\"image\":{\"@id\":\"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#primaryimage\"},\"thumbnailUrl\":\"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg\",\"articleSection\":[\"Computer Science\"],\"inLanguage\":\"en-US\"},{\"@type\":[\"Person\",\"Organization\"],\"@id\":\"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e\",\"name\":\"Jacek Jeznach\",\"image\":{\"@type\":\"ImageObject\",\"@id\":\"https:\/\/jacekjeznach.com\/#personlogo\",\"inLanguage\":\"en-US\",\"url\":\"https:\/\/secure.gravatar.com\/avatar\/dc947f87f7bb9ca215513aa49e41203f?s=96&d=mm&r=g\",\"contentUrl\":\"https:\/\/secure.gravatar.com\/avatar\/dc947f87f7bb9ca215513aa49e41203f?s=96&d=mm&r=g\",\"caption\":\"Jacek Jeznach\"},\"logo\":{\"@id\":\"https:\/\/jacekjeznach.com\/#personlogo\"},\"url\":\"https:\/\/jacekjeznach.com\/author\/jeznacki1234\/\"}]}<\/script>\n<!-- \/ Yoast SEO plugin. -->","yoast_head_json":{"title":"Algorithms and Data Structures (Part 2) | Computer Science | JJ","description":"how the term algorithm is used in applications of computer science.how to create flowcharts.the details of data structures, such as arrays and stacks.how sorting algorithms work, including quick and bubble sort.how the quality of different algorithms is evaluated.","robots":{"index":"index","follow":"follow","max-snippet":"max-snippet:-1","max-image-preview":"max-image-preview:large","max-video-preview":"max-video-preview:-1"},"canonical":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/","og_locale":"en_US","og_type":"article","og_title":"Algorithms and Data Structures (Part 2) | Computer Science | JJ","og_description":"how the term algorithm is used in applications of computer science.how to create flowcharts.the details of data structures, such as arrays and stacks.how sorting algorithms work, including quick and bubble sort.how the quality of different algorithms is evaluated.","og_url":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/","og_site_name":"JJ","article_published_time":"2021-01-05T08:27:38+00:00","article_modified_time":"2022-02-03T09:42:53+00:00","og_image":[{"width":2048,"height":1367,"url":"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg","type":"image\/jpeg"}],"twitter_card":"summary","twitter_creator":"@JeznachJacek","twitter_site":"@JeznachJacek","twitter_misc":{"Written by":"Jacek Jeznach","Est. reading time":"13 minutes"},"schema":{"@context":"https:\/\/schema.org","@graph":[{"@type":"WebSite","@id":"https:\/\/jacekjeznach.com\/#website","url":"https:\/\/jacekjeznach.com\/","name":"JJ","description":"Hire Professional  WordPress Expert - providing multiple services including website maintenance and interactive solutions","publisher":{"@id":"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e"},"potentialAction":[{"@type":"SearchAction","target":{"@type":"EntryPoint","urlTemplate":"https:\/\/jacekjeznach.com\/?s={search_term_string}"},"query-input":"required name=search_term_string"}],"inLanguage":"en-US"},{"@type":"ImageObject","@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#primaryimage","inLanguage":"en-US","url":"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg","contentUrl":"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg","width":2048,"height":1367},{"@type":"WebPage","@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#webpage","url":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/","name":"Algorithms and Data Structures (Part 2) | Computer Science | JJ","isPartOf":{"@id":"https:\/\/jacekjeznach.com\/#website"},"primaryImageOfPage":{"@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#primaryimage"},"datePublished":"2021-01-05T08:27:38+00:00","dateModified":"2022-02-03T09:42:53+00:00","description":"how the term algorithm is used in applications of computer science.how to create flowcharts.the details of data structures, such as arrays and stacks.how sorting algorithms work, including quick and bubble sort.how the quality of different algorithms is evaluated.","breadcrumb":{"@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#breadcrumb"},"inLanguage":"en-US","potentialAction":[{"@type":"ReadAction","target":["https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/"]}]},{"@type":"BreadcrumbList","@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#breadcrumb","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https:\/\/jacekjeznach.com\/"},{"@type":"ListItem","position":2,"name":"Algorithms and Data Structures (Part 2)"}]},{"@type":"Article","@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#article","isPartOf":{"@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#webpage"},"author":{"@id":"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e"},"headline":"Algorithms and Data Structures (Part 2)","datePublished":"2021-01-05T08:27:38+00:00","dateModified":"2022-02-03T09:42:53+00:00","mainEntityOfPage":{"@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#webpage"},"wordCount":2716,"publisher":{"@id":"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e"},"image":{"@id":"https:\/\/jacekjeznach.com\/sorting-searching-algorithms\/#primaryimage"},"thumbnailUrl":"https:\/\/jacekjeznach.com\/wp-content\/uploads\/2022\/01\/binary-code-4512291.jpg","articleSection":["Computer Science"],"inLanguage":"en-US"},{"@type":["Person","Organization"],"@id":"https:\/\/jacekjeznach.com\/#\/schema\/person\/5adfd5bffa0fa377e81b67da26f9730e","name":"Jacek Jeznach","image":{"@type":"ImageObject","@id":"https:\/\/jacekjeznach.com\/#personlogo","inLanguage":"en-US","url":"https:\/\/secure.gravatar.com\/avatar\/dc947f87f7bb9ca215513aa49e41203f?s=96&d=mm&r=g","contentUrl":"https:\/\/secure.gravatar.com\/avatar\/dc947f87f7bb9ca215513aa49e41203f?s=96&d=mm&r=g","caption":"Jacek Jeznach"},"logo":{"@id":"https:\/\/jacekjeznach.com\/#personlogo"},"url":"https:\/\/jacekjeznach.com\/author\/jeznacki1234\/"}]}},"_links":{"self":[{"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/posts\/2375"}],"collection":[{"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/comments?post=2375"}],"version-history":[{"count":7,"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/posts\/2375\/revisions"}],"predecessor-version":[{"id":2378,"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/posts\/2375\/revisions\/2378"}],"wp:featuredmedia":[{"embeddable":true,"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/media\/2267"}],"wp:attachment":[{"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/media?parent=2375"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/categories?post=2375"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/jacekjeznach.com\/wp-json\/wp\/v2\/tags?post=2375"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}